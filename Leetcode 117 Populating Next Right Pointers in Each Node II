Solution 1: Using queue (extra space of O(N)).
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (root == NULL) return;
        queue<TreeLinkNode* > nodequeue;
        nodequeue.push(root);
        TreeLinkNode* temp;
        TreeLinkNode* pre; 
        while (!nodequeue.empty()) {
            int level_size = nodequeue.size();
            pre = NULL; //rest pre to NULL at the beginning of the level.
            for (int i = 0; i < level_size; ++i) {
                temp = nodequeue.front();
                temp->next = pre;
                if (temp->right!=NULL) nodequeue.push(temp->right);
                if (temp->left!=NULL) nodequeue.push(temp->left);
                pre = temp;
                nodequeue.pop();
            }
        }     
    }
};

Solution 2: constant extra space. The key is to use two pointers: one is representing the head of the next level and the other is to representing the current node.

class Solution {
public:
    void connect(TreeLinkNode *root) {
      if (root == NULL) return;
      TreeLinkNode* cur = root;
      TreeLinkNode* head = root;
      TreeLinkNode* tail = NULL;
      while(head != NULL) {
          cur = head;
          head = NULL; //head for next level.
          while (cur!=NULL){
              if (cur->left!=NULL) {
                  if (head == NULL) tail = head = cur->left;
                  else {
                      tail->next = cur->left;
                      tail = tail->next;
                  }
              } 
              if (cur->right != NULL) {
                  if (head == NULL) tail = head = cur->right;
                  else {
                      tail->next = cur->right;
                      tail = tail->next;
                  }
              }
              cur = cur->next;
          }
      }
    }
};
